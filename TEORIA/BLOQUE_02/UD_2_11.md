
---

# üîπ Unidad 2.11 ‚Äì Iteradores e Iterables

## üéØ Objetivos de aprendizaje

Al finalizar esta unidad ser√°s capaz de:

* Entender qu√© es un **iterable** y qu√© es un **iterador** en Python.
* Diferenciar entre ambos conceptos.
* Recorrer iterables usando bucles `for`.
* Crear un iterador usando `iter()` y recorrerlo con `next()`.
* Comprender la relaci√≥n entre listas, tuplas, diccionarios, sets y strings con iteradores.

---

## 1Ô∏è‚É£ ¬øQu√© es un iterable?

Un **iterable** es cualquier objeto en Python del que se pueden obtener sus elementos **uno a uno**.

> Ejemplos de iterables: listas, tuplas, strings, diccionarios, sets, rangos (`range`).

### Ejemplo con lista:

```python
lista = [10, 20, 30]

for elemento in lista:
    print(elemento)
```

‚û°Ô∏è Salida:

```
10
20
30
```

üîπ Observaci√≥n:

* La lista es un **iterable**, y el bucle `for` se encarga de obtener cada elemento en cada vuelta.

---

## 2Ô∏è‚É£ ¬øQu√© es un iterador?

Un **iterador** es un objeto que **mantiene el estado de la iteraci√≥n** sobre un iterable.
Se puede recorrer **paso a paso**, usando la funci√≥n `next()`.

### Crear un iterador a partir de un iterable

```python
lista = [10, 20, 30]

it = iter(lista)  # Creamos un iterador
print(next(it))   # 10
print(next(it))   # 20
print(next(it))   # 30
```

üîπ Explicaci√≥n:

* `iter(lista)` crea un **iterador** a partir de la lista.
* `next(it)` devuelve el siguiente elemento del iterador.
* Cuando se acaban los elementos, `next()` genera un **StopIteration**.

---

## 3Ô∏è‚É£ Iterables vs Iteradores

| Concepto | Qu√© hace                                                         | Ejemplo                           |
| -------- | ---------------------------------------------------------------- | --------------------------------- |
| Iterable | Se puede recorrer, pero no ‚Äúrecuerda‚Äù la posici√≥n                | lista, tupla, string, diccionario |
| Iterador | Permite recorrer los elementos uno a uno y **recuerda** d√≥nde va | objeto creado con `iter()`        |

üîπ Nota: Todo **iterador** es un **iterable**, pero no todo iterable es un iterador.

---

## 4Ô∏è‚É£ Recorrer un iterador usando `next()` con valor por defecto (`None`)

Adem√°s de usar un bucle `for`, podemos avanzar manualmente por un iterador usando la funci√≥n `next()`.  
Una forma pr√°ctica y limpia de evitar la excepci√≥n `StopIteration` es proporcionar un **valor por defecto**, que se devolver√° cuando el iterador se agote.

### Ejemplo:

```python
lista = [1, 2, 3]
it = iter(lista)

elemento = next(it, None)
while elemento is not None:
    print(elemento)
    elemento = next(it, None)
```

‚û°Ô∏è Salida:

```
1
2
3
```

üîπ Explicaci√≥n:

* next(it, None) intenta obtener el siguiente elemento del iterador.
* Si a√∫n quedan elementos, los devuelve normalmente.
* Si el iterador se agota, en lugar de lanzar StopIteration, devuelve None.
* El bucle finaliza cuando recibe ese None, por lo que no es necesario gestionar excepciones.
Esta t√©cnica permite recorrer un iterador de forma controlada sin capturar errores.

---

## 5Ô∏è‚É£ Iterables comunes

### String

```python
texto = "Python"
for letra in texto:
    print(letra)
```

‚û°Ô∏è Salida:

```
P
y
t
h
o
n
```

### Tupla

```python
tupla = (1, 2, 3)
for num in tupla:
    print(num)
```

### Diccionario

```python
dic = {"a": 1, "b": 2}
for clave in dic:
    print(clave, dic[clave])
```

### Range

```python
for i in range(5):
    print(i)
```

---

## 6Ô∏è‚É£ Crear un iterador infinito con `iter()` y una funci√≥n

Se puede crear un iterador que siga generando valores mientras una funci√≥n devuelva resultados:

```python
import random

def aleatorio():
    return random.randint(1, 100)

it = iter(aleatorio, 50)  # Iterador que genera n√∫meros hasta que aparezca 50
for n in it:
    print(n)
```

üîπ Explicaci√≥n:

* La funci√≥n `iter(funcion, valor_sentinel)` genera valores hasta que la funci√≥n devuelve el **valor_sentinel**.

---

## üìù Ejercicio guiado

1. Crea una lista de n√∫meros del 1 al 5.
2. Convierte la lista en un iterador.
3. Imprime cada elemento usando `next()` dentro de un `while`.

---

## üìù Actividad avanzada ‚Äì **`b2_11_2_iteradores_mejorado.py`**

### Objetivo

Practicar iteradores manuales y procesamiento de datos, mostrando un **reporte completo y ordenado** de estudiantes, con **nota promedio**, estado y control de iteradores.

---

### Enunciado

1. Tenemos un diccionario con estudiantes y sus notas en **tres materias**:

```python
estudiantes = {
    "Ana": [8, 7, 9],
    "Luis": [7, 6, 8],
    "Marta": [9, 10, 9],
    "Carlos": [6, 7, 5],
    "Laura": [10, 9, 10]
}
```

2. Crea un **iterador** sobre las claves del diccionario.

3. Recorre el iterador usando `next()` dentro de un `while True`.

4. Para cada estudiante:

   * Calcula el **promedio** de sus notas.
   * Determina el **estado**:

     * `"Aprobado"` si promedio ‚â• 6.5
     * `"En recuperaci√≥n"` si promedio ‚â• 5 y < 6.5
     * `"Reprobado"` si promedio < 5

5. Imprime un **reporte claro y ordenado**:

```
Ana - Notas: [8, 7, 9], Promedio: 8.0, Estado: Aprobado
Luis - Notas: [7, 6, 8], Promedio: 7.0, Estado: Aprobado
Marta - Notas: [9, 10, 9], Promedio: 9.33, Estado: Aprobado
Carlos - Notas: [6, 7, 5], Promedio: 6.0, Estado: En recuperaci√≥n
Laura - Notas: [10, 9, 10], Promedio: 9.67, Estado: Aprobado
```

---

### C√≥digo resuelto y mejorado

```python
# b2_11_2_iteradores_mejorado.py

# Diccionario de estudiantes con notas en tres materias
estudiantes = {
    "Ana": [8, 7, 9],
    "Luis": [7, 6, 8],
    "Marta": [9, 10, 9],
    "Carlos": [6, 7, 5],
    "Laura": [10, 9, 10]
}

# Creamos un iterador sobre las claves del diccionario
it_estudiantes = iter(estudiantes)

# Recorremos manualmente el iterador
while True:
    try:
        nombre = next(it_estudiantes)
        notas = estudiantes[nombre]

        # Calculamos el promedio redondeado a 2 decimales
        promedio = round(sum(notas) / len(notas), 2)

        # Determinamos el estado
        if promedio >= 6.5:
            estado = "Aprobado"
        elif promedio >= 5:
            estado = "En recuperaci√≥n"
        else:
            estado = "Reprobado"

        # Mostramos el reporte
        print(f"{nombre} - Notas: {notas}, Promedio: {promedio}, Estado: {estado}")

    except StopIteration:
        # Finalizamos cuando el iterador se agota
        break
```

---

