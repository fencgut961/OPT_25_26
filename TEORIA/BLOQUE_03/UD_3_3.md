
---

# ğŸ”¹ Unidad 3.3 â€“ CreaciÃ³n de mÃ³dulos personalizados y organizaciÃ³n de proyectos

---

## ğŸ¯ Objetivos de aprendizaje

* Comprender quÃ© es un **mÃ³dulo personalizado** en Python.
* Crear y reutilizar funciones dentro de mÃ³dulos propios.
* Importar mÃ³dulos creados en distintos programas.
* Diferenciar entre mÃ³dulos, paquetes y proyectos.
* Conocer el papel del archivo `__init__.py` en los paquetes.
* Comparar el uso de **carpetas normales** y **paquetes** en Python.
* Organizar un proyecto sencillo en varias carpetas y archivos.

---

## ğŸ“š ExplicaciÃ³n teÃ³rica

### 1. Â¿QuÃ© es un mÃ³dulo?

Un **mÃ³dulo** es un archivo de Python (`.py`) que contiene cÃ³digo reutilizable (funciones, clases, variables).
Ejemplo: `math`, `os`, `sys`.

AdemÃ¡s de los mÃ³dulos estÃ¡ndar y externos, es posible **crear mÃ³dulos personalizados**.

---

### 2. CreaciÃ³n de un mÃ³dulo propio

```python
# utilidades.py
def saludar(nombre):
    return f"Hola, {nombre}!"

def sumar(a, b):
    return a + b
```

Uso en otro archivo:

```python
# programa.py
import utilidades

print(utilidades.saludar("Ana"))
print(utilidades.sumar(3, 4))
```

---

### 3. Formas de importar

```python
import utilidades                 # importa todo
from utilidades import saludar    # importa solo lo necesario
import utilidades as u            # alias
```

---

### 4. Paquetes en Python y `__init__.py`

Un **paquete** es una carpeta que agrupa varios mÃ³dulos y que contiene un archivo especial `__init__.py`.

* Si la carpeta **no tiene** `__init__.py`, Python la trata como una carpeta normal.
* Si la carpeta **tiene** `__init__.py`, Python la reconoce como un **paquete**.
* El archivo `__init__.py` puede estar vacÃ­o o incluir importaciones y cÃ³digo de inicializaciÃ³n.

Ejemplo de estructura:

```
mi_proyecto/
â”‚â”€â”€ main.py
â”‚â”€â”€ utilidades/
â”‚   â”‚â”€â”€ __init__.py
â”‚   â”‚â”€â”€ cadenas.py
â”‚   â”‚â”€â”€ matematicas.py
```

En `main.py`:

```python
from utilidades.matematicas import sumar
from utilidades.cadenas import contar_letras
```

---

### 5. Diferencia entre carpetas y paquetes

| Aspecto               | Carpeta normal                  | Paquete (`__init__.py`)           |
| --------------------- | ------------------------------- | --------------------------------- |
| Reconocido por Python | âŒ No                            | âœ… SÃ­                              |
| Importaciones         | Necesita hacks con `sys.path`   | Naturales con `import paquete`    |
| InicializaciÃ³n        | No hay                          | Puede ejecutar cÃ³digo al importar |
| CentralizaciÃ³n        | No se puede                     | SÃ­, en `__init__.py`              |
| ReutilizaciÃ³n         | DifÃ­cil mover a otros proyectos | FÃ¡cil copiar o instalar con pip   |

#### Ejemplo con carpeta normal (sin `__init__.py`):

```
mi_proyecto/
â”‚â”€â”€ main.py
â”‚â”€â”€ utilidades/
â”‚   â”‚â”€â”€ matematicas.py
```

`main.py`:

```python
import utilidades.matematicas   # âŒ Error
```

Para que funcione habrÃ­a que forzar la ruta:

```python
import sys
sys.path.append("utilidades")   # ğŸš¨ hack poco limpio

import matematicas
print(matematicas.sumar(3, 4))
```

---

#### Ejemplo con paquete (con `__init__.py`):

```
mi_proyecto/
â”‚â”€â”€ main.py
â”‚â”€â”€ utilidades/
â”‚   â”‚â”€â”€ __init__.py
â”‚   â”‚â”€â”€ matematicas.py
â”‚   â”‚â”€â”€ cadenas.py
```

`matematicas.py`:

```python
def sumar(a, b):
    return a + b
```

`__init__.py`:

```python
from .matematicas import sumar
```

`main.py`:

```python
import utilidades

print(utilidades.sumar(5, 3))  # âœ… 8
```

---

### 6. OrganizaciÃ³n de proyectos

Buenas prÃ¡cticas bÃ¡sicas:

* Mantener un archivo principal (`main.py`) como punto de entrada.
* Crear mÃ³dulos separados para funciones reutilizables.
* Usar nombres claros y descriptivos.
* Convertir carpetas en paquetes cuando el proyecto crezca.

Ejemplo simple:

```
proyecto_notas/
â”‚â”€â”€ main.py
â”‚â”€â”€ notas.py
â”‚â”€â”€ utilidades.py
```

Ejemplo con paquete:

```
gestor_tareas/
â”‚â”€â”€ main.py
â”‚â”€â”€ gestor/
â”‚   â”‚â”€â”€ __init__.py
â”‚   â”‚â”€â”€ tareas.py
â”‚   â”‚â”€â”€ utils.py
```

---

## ğŸ’» Ejemplos prÃ¡cticos

Ejemplo 1 â€” MÃ³dulo de operaciones:

```python
# operaciones.py
def cuadrado(x):
    return x * x

def cubo(x):
    return x * x * x
```

```python
# main.py
import operaciones

print("2 al cuadrado:", operaciones.cuadrado(2))
print("3 al cubo:", operaciones.cubo(3))
```

---

Ejemplo 2 â€” Reutilizar un mÃ³dulo en varios programas:

```python
# saludos.py
def hola():
    return "Â¡Hola!"

def adios():
    return "Â¡AdiÃ³s!"
```

```python
# app1.py
import saludos
print(saludos.hola())
```

```python
# app2.py
from saludos import adios
print(adios())
```

---

## ğŸ“ Actividad guiada â€” `mis_modulos`

1. Crear un mÃ³dulo `matematicas.py` con funciones:

   * `suma(a, b)`
   * `resta(a, b)`
   * `multiplicar(a, b)`
   * `dividir(a, b)` (controlando la divisiÃ³n por cero).

2. Crear un mÃ³dulo `cadenas.py` con funciones:

   * `contar_letras(texto)` â†’ devuelve el nÃºmero de caracteres.
   * `invertir(texto)` â†’ devuelve el texto al revÃ©s.

3. Crear un archivo `main.py`:

   * Importar los dos mÃ³dulos.
   * Pedir al usuario un nÃºmero y un texto.
   * Usar las funciones de `matematicas.py` y `cadenas.py` con esos datos.

ğŸ‘‰ **Objetivo:** comprender cÃ³mo separar funciones en mÃ³dulos y reutilizarlas en un programa principal.

---

## ğŸ“ Reto a entregar â€” `gestor_tareas_modular`

Organiza un **mini proyecto** en varios archivos que funcione como un gestor sencillo de tareas.

### ğŸ”¹ Estructura del proyecto

```
gestor_tareas/
â”‚â”€â”€ main.py
â”‚â”€â”€ gestor/
â”‚   â”‚â”€â”€ __init__.py
â”‚   â”‚â”€â”€ tareas.py
â”‚   â”‚â”€â”€ utils.py
```

### ğŸ”¹ Detalles de cada archivo

1. **`tareas.py`**

   * `cargar_tareas()` â†’ lee las tareas desde `tareas.txt` (si no existe, devuelve lista vacÃ­a).
   * `guardar_tarea(tarea)` â†’ aÃ±ade una nueva tarea al archivo.
   * `listar_tareas()` â†’ devuelve todas las tareas en forma de lista numerada.

2. **`utils.py`**

   * `mostrar_menu()` â†’ imprime el menÃº de opciones.
   * `pedir_opcion()` â†’ pide un nÃºmero vÃ¡lido (1, 2 o 3).

3. **`__init__.py`**

   * Centraliza las importaciones:

   ```python
   from .tareas import cargar_tareas, guardar_tarea, listar_tareas
   from .utils import mostrar_menu, pedir_opcion
   ```

4. **`main.py`**

   * Importa directamente el paquete `gestor`.
   * Muestra un menÃº con opciones:

     ```
     1. Ver tareas
     2. AÃ±adir tarea
     3. Salir
     ```
   * Ejecuta la acciÃ³n correspondiente.

---

### ğŸ”¹ Ejemplo de ejecuciÃ³n

```
--- Gestor de Tareas ---
1. Ver tareas
2. AÃ±adir tarea
3. Salir
Elige una opciÃ³n: 1

Tareas actuales:
1. Comprar pan
2. Estudiar Python

--- Gestor de Tareas ---
1. Ver tareas
2. AÃ±adir tarea
3. Salir
Elige una opciÃ³n: 2

Escribe la nueva tarea: Hacer ejercicio
âœ… Tarea guardada con Ã©xito.

--- Gestor de Tareas ---
1. Ver tareas
2. AÃ±adir tarea
3. Salir
Elige una opciÃ³n: 3
ğŸ‘‹ Â¡Hasta la prÃ³xima!
```

---

## ğŸ“Œ RelaciÃ³n con RA

* **RA3.ce5 (e):** se han creado y utilizado mÃ³dulos personalizados en Python.
* **RA3.ce6 (f):** se ha organizado un proyecto sencillo en varios archivos y paquetes.

---
