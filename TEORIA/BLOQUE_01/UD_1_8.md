
---

# 🔹 Unidad 1.8 – Depuración en IntelliJ 🕵️‍♂️

## 🎯 Objetivos de aprendizaje

* Comprender qué es la **depuración** y por qué es importante.
* Aprender a usar **breakpoints** en IntelliJ.
* Inspeccionar **variables** mientras el programa se ejecuta.
* Detectar y corregir **errores lógicos**.

---

## 🛠️ ¿Qué es la depuración?

La **depuración (debugging)** es el proceso de **detectar, analizar y corregir errores** en un programa.
Un error puede hacer que el programa falle, se bloquee o, peor aún, que **funcione mal sin darnos cuenta**.

### 📌 Tipos de errores más comunes:

* **Errores de sintaxis** → impiden que el programa se ejecute.
  Ejemplo: olvidar los dos puntos `:` después de un `if`.
* **Errores lógicos** → el programa se ejecuta, pero da un resultado incorrecto.
  Ejemplo: calcular mal un promedio porque faltan paréntesis.

👉 Los **errores lógicos** son los más difíciles de detectar, y aquí es donde el **depurador de IntelliJ** resulta clave.

---

## 🔴 Breakpoints (puntos de interrupción)

Un **breakpoint** es un marcador que detiene la ejecución del programa en una línea específica para inspeccionar lo que está ocurriendo en ese punto.

### 📌 Pasos en IntelliJ IDEA:

1. Haz clic en el **margen izquierdo** de la línea donde quieras detener el programa → aparecerá un **círculo rojo**.
2. Ejecuta el programa en modo **Debug** (botón con un insecto 🪲).
3. El programa se **pausará** antes de ejecutar esa línea.

➡️ Esto permite revisar qué valores tienen las variables y cómo avanza el flujo del programa.

---

## 🔍 Inspección de variables

Cuando el programa está **pausado** en un breakpoint:

* Puedes ver el **valor actual de todas las variables** en la ventana del depurador.
* Puedes **ejecutar paso a paso** para seguir el flujo del programa:

  * **Step Over** → ejecuta la línea actual y pasa a la siguiente.
  * **Step Into** → entra dentro de una función llamada en esa línea.
  * **Step Out** → sale de la función y regresa al nivel superior.

👉 Esto ayuda a descubrir en qué momento una variable toma un valor incorrecto.

---

## 📚 Ejemplo de error lógico

El siguiente programa debería calcular el promedio de tres números, pero tiene un error:

```python
# Programa con error
num1 = 10
num2 = 20
num3 = 30

promedio = num1 + num2 + num3 / 3
print(f"El promedio es: {promedio}")  # Espera 20, pero muestra 40.0
```

📌 **Explicación del error**:
Python aplica primero la división (`/`) y luego la suma (por la **precedencia de operadores**).
En realidad, queremos que **sume todo antes de dividir**.

✅ **Corrección**:

```python
promedio = (num1 + num2 + num3) / 3
print(f"El promedio es: {promedio}")  # Ahora sí muestra 20.0
```

👉 Con el depurador, el alumno puede **detenerse en la línea del cálculo**, inspeccionar el valor de `promedio` y descubrir por qué no es el esperado.

---

## 📝 Ejercicio guiado

Crea un script que:

1. Pida dos números al usuario.
2. Calcule la división de ambos.
3. Introduzca a propósito un error: usa `num1 + num2 / 2` en lugar de `(num1 + num2) / 2`.
4. Ejecútalo en **modo depuración** en IntelliJ y observa qué valores toman las variables en cada paso.

---

## 📝 Actividad evaluable - **`b1_9_analizador_notas.py`** 

Crea un script que:

1. Pida al usuario **tres notas**.
2. Calcule el promedio.
3. Introduzca un **error lógico** en el cálculo (como en el ejemplo anterior).
4. Usa IntelliJ en modo depuración para encontrar y corregir el error.
5. Añade un **docstring al inicio** explicando qué hacía mal el programa y cómo se corrigió.

---

## 💡 Consejos prácticos de depuración

* **Divide y vencerás** → si un programa es largo, depúralo en secciones pequeñas.
* **Usa print() como apoyo** → aunque el depurador es más potente, imprimir valores puntuales también ayuda.
* **No ignores los warnings** → IntelliJ suele mostrar advertencias antes de que se conviertan en errores.
* **Depurar no es solo corregir** → también sirve para **entender mejor cómo funciona tu código**.

---

## ➡️ RA1. ce5

Se han seguido buenas prácticas de **organización y documentación del código**, aplicando indentación adecuada y usando la depuración para **detectar y corregir errores de manera eficaz**.

---
---

# 📝 ACTIVIDAD FINAL BLOQUE 01

## 🎯 Objetivos de aprendizaje

* Poner en práctica **todos los conceptos aprendidos en este módulo**: variables, tipos de datos, operadores, condicionales, bucles, control de flujo, buenas prácticas y depuración.
* Diseñar un programa **más completo y funcional**.
* Documentar correctamente el código siguiendo **PEP 8**.
* Usar el **depurador de IntelliJ** para localizar y corregir errores.

---

Crear un sistema de **registro e inicio de sesión** con validación de contraseñas seguras, simulando de forma sencilla cómo funcionan muchas aplicaciones reales.
Crea un script **`b1_10_login.py`** que:

### 📌 Requisitos del programa

1. El programa debe mostrar un menú principal con tres opciones:

   * **[1]. Registrarse** → El usuario crea un nuevo nombre de usuario y contraseña.
   * **[2]. Iniciar sesión** → El usuario introduce su nombre y contraseña para acceder.
   * **[3]. Salir** → Finaliza el programa.

2. **Registro de usuarios:**

   * Los usuarios se almacenan en un **diccionario** donde:

     * La **clave** es el nombre de usuario.
     * El **valor** es la contraseña asociada.

   * Antes de aceptar la contraseña, debes validarla con estas reglas:

     * Mínimo **8 caracteres**.
     * Contener al menos **una mayúscula**.
     * Contener al menos **un número**.
     * Contener al menos **un símbolo especial** (`!@#$%&*?`, etc.).

   * Si no cumple las reglas → muestra un mensaje de error y vuelve a pedir la contraseña.

3. **Inicio de sesión:**

   * Verifica si el usuario existe en el diccionario.
   * Si existe y la contraseña es correcta → muestra **“Acceso concedido ✅”**.
   * Si el usuario no existe o la contraseña es incorrecta → muestra **“Acceso denegado ⛔”**.
   * El usuario tendrá un máximo de **3 intentos** para introducir su contraseña correctamente.

     * Si falla las 3 veces seguidas → mostrar **“Demasiados intentos fallidos 🚫. Regresando al menú principal.”** y volver al menú.

4. El programa debe ejecutarse en bucle hasta que el usuario elija la opción **Salir**.

---

## 📚 Ejemplo de funcionamiento

### Registro exitoso:

```
¿Qué quieres hacer? [1] Registrarse  [2] Iniciar sesión  [3] Salir: 1
Introduce un nombre de usuario: ana
Introduce una contraseña: hola123
Contraseña insegura ❌. Debe tener al menos 8 caracteres, una mayúscula, un número y un símbolo.
Introduce una contraseña: Hola123!
Usuario registrado con éxito ✅
```

### Inicio de sesión con éxito:

```
¿Qué quieres hacer? [1] Registrarse  [2] Iniciar sesión  [3] Salir: 2
Introduce tu usuario: ana
Introduce tu contraseña: Hola123!
Acceso concedido ✅. Bienvenida, ana.
```

### Inicio de sesión fallido (máx. 3 intentos):

```
¿Qué quieres hacer? [1] Registrarse  [2] Iniciar sesión  [3] Salir: 2
Introduce tu usuario: ana
Introduce tu contraseña: 123456
Acceso denegado ⛔. Intento 1/3
Introduce tu contraseña: 1234567
Acceso denegado ⛔. Intento 2/3
Introduce tu contraseña: Holaaa!
Acceso denegado ⛔. Intento 3/3
Demasiados intentos fallidos 🚫. Regresando al menú principal.
```

---

## 🛠️ Recomendaciones de diseño

* Usa **funciones** para organizar tu código:

  * `registrar_usuario(diccionario_usuarios)`
  * `validar_contraseña(contraseña)`
  * `iniciar_sesion(diccionario_usuarios)`
* Utiliza un **bucle while** para mantener el menú activo hasta que se seleccione la opción de salir.
* Muestra mensajes claros y amigables en cada interacción.
* Añade un **docstring** al inicio y comentarios en las partes más importantes del código.
* Aplica la guía de estilo **PEP 8** para indentación y nombres de variables.

---

## ✔️ Rúbrica de evaluación (RA1)

* **RA1. ce1** → Uso correcto de la sintaxis básica de Python: variables, tipos de datos y operadores aritméticos.
* **RA1. ce2** → Empleo adecuado de operadores de comparación (`==`, `!=`, `<`, `>`) y lógicos (`and`, `or`, `not`) en condicionales y bucles.
* **RA1. ce3** → Aplicación correcta de estructuras de control (`if`, `elif`, `else`) para la toma de decisiones y control de flujo.
* **RA1. ce4** → Uso de bucles `for` y `while` para iterar y controlar la repetición de tareas.
* **RA1. ce5** → Buenas prácticas de organización y documentación del código: indentación adecuada, claridad en los mensajes y manejo eficaz de errores.

---
